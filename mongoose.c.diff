diff --git a/src/mongoose.c b/src/mongoose.c
index 9057fc3..9026762 100644
--- a/src/mongoose.c
+++ b/src/mongoose.c
@@ -5253,9 +5249,7 @@ static enum mg_ssl_if_result mg_ssl_if_mbed_err(struct mg_connection *nc,
     nc->flags |= MG_F_CLOSE_IMMEDIATELY;
     res = MG_SSL_OK;
   } else {
-    char buffer[256];
-    mbedtls_strerror(ret, buffer, 256);
-    LOG(LL_ERROR, ("%p mbedTLS error: -0x%04x: %s", nc, -ret, buffer));
+    LOG(LL_ERROR, ("%p mbedTLS error: -0x%04x", nc, -ret));
     nc->flags |= MG_F_CLOSE_IMMEDIATELY;
     res = MG_SSL_ERROR;
   }
@@ -5386,7 +5380,7 @@ static enum mg_ssl_if_result mg_use_ca_cert(struct mg_ssl_if_ctx *ctx,
   ca_cert = strdup(ca_cert);
   mbedtls_ssl_conf_ca_chain_file(ctx->conf, ca_cert, NULL);
 #else
-  if (mbedtls_x509_crt_parse(ctx->ca_cert, (uint8_t *)ca_cert, strlen(ca_cert) + 1) < 0) {
+  if (mbedtls_x509_crt_parse_file(ctx->ca_cert, ca_cert) != 0) {
     return MG_SSL_ERROR;
   }
   mbedtls_ssl_conf_ca_chain(ctx->conf, ctx->ca_cert, NULL);
@@ -5406,11 +5400,11 @@ static enum mg_ssl_if_result mg_use_cert(struct mg_ssl_if_ctx *ctx,
   mbedtls_x509_crt_init(ctx->cert);
   ctx->key = (mbedtls_pk_context *) MG_CALLOC(1, sizeof(*ctx->key));
   mbedtls_pk_init(ctx->key);
-  if (mbedtls_x509_crt_parse(ctx->cert, (uint8_t *)cert, strlen(cert) + 1) < 0) {
+  if (mbedtls_x509_crt_parse_file(ctx->cert, cert) != 0) {
     MG_SET_PTRPTR(err_msg, "Invalid SSL cert");
     return MG_SSL_ERROR;
   }
-  if (mbedtls_pk_parse_key(ctx->key, (uint8_t *)key, strlen(key) + 1, NULL, 0) < 0) {
+  if (mbedtls_pk_parse_keyfile(ctx->key, key, NULL) != 0) {
     MG_SET_PTRPTR(err_msg, "Invalid SSL key");
     return MG_SSL_ERROR;
   }
@@ -6001,9 +5995,6 @@ struct mg_http_proto_data {
   struct mg_http_proto_data_chuncked chunk;
   struct mg_http_endpoint *endpoints;
   mg_event_handler_t endpoint_handler;
-#if MG_ENABLE_CALLBACK_USERDATA
-  void *user_data;
-#endif
   struct mg_reverse_proxy_data reverse_proxy_data;
   size_t rcvd; /* How many bytes we have received. */
 };
@@ -6580,13 +6571,11 @@ void mg_http_handler(struct mg_connection *nc, int ev,
       mp.var_name = pd->mp_stream.var_name;
       mp.file_name = pd->mp_stream.file_name;
       mg_call(nc, (pd->endpoint_handler ? pd->endpoint_handler : nc->handler),
-              (pd->endpoint_handler ? pd->user_data : nc->user_data),
-              MG_EV_HTTP_PART_END, &mp);
+              nc->user_data, MG_EV_HTTP_PART_END, &mp);
       mp.var_name = NULL;
       mp.file_name = NULL;
       mg_call(nc, (pd->endpoint_handler ? pd->endpoint_handler : nc->handler),
-              (pd->endpoint_handler ? pd->user_data : nc->user_data),
-              MG_EV_HTTP_MULTIPART_REQUEST_END, &mp);
+              nc->user_data, MG_EV_HTTP_MULTIPART_REQUEST_END, &mp);
     } else
 #endif
         if (io->len > 0 &&
@@ -6603,7 +6592,7 @@ void mg_http_handler(struct mg_connection *nc, int ev,
     }
     pd->rcvd = 0;
     if (pd->endpoint_handler != NULL && pd->endpoint_handler != nc->handler) {
-      mg_call(nc, pd->endpoint_handler, pd->user_data, ev, NULL);
+      mg_call(nc, pd->endpoint_handler, nc->user_data, ev, NULL);
     }
   }
 
@@ -6822,7 +6811,6 @@ static void mg_http_multipart_begin(struct mg_connection *nc,
     ep = mg_http_get_endpoint_handler(nc->listener, &hm->uri);
     if (ep != NULL) {
       pd->endpoint_handler = ep->handler;
-      pd->user_data = ep->user_data;
     }
 
     mg_http_call_endpoint_handler(nc, MG_EV_HTTP_MULTIPART_REQUEST, hm);
@@ -6848,7 +6836,7 @@ static size_t mg_http_multipart_call_handler(struct mg_connection *c, int ev,
   mp.data.p = data;
   mp.data.len = data_len;
   mp.num_data_consumed = data_len;
-  mg_call(c, pd->endpoint_handler, pd->user_data, ev, &mp);
+  mg_call(c, pd->endpoint_handler, c->user_data, ev, &mp);
   pd->mp_stream.user_data = mp.user_data;
   pd->mp_stream.data_avail = (mp.num_data_consumed != data_len);
   return mp.num_data_consumed;
@@ -7453,13 +7441,9 @@ int mg_get_http_var(const struct mg_str *buf, const char *name, char *dst,
     dst[0] = '\0';
 
     for (p = buf->p; p + name_len < e; p++) {
-      if ((p == buf->p || p[-1] == '&') && 
-          (p[name_len] == '=' || p[name_len] == '&') &&
+      if ((p == buf->p || p[-1] == '&') && p[name_len] == '=' &&
           !mg_ncasecmp(name, p, name_len)) {
-        p += name_len;
-        if('=' == *p) {
-          p++;
-        }
+        p += name_len + 1;
         s = (const char *) memchr(p, '&', (size_t)(e - p));
         if (s == NULL) {
           s = e;
@@ -8939,7 +8923,6 @@ static void mg_http_call_endpoint_handler(struct mg_connection *nc, int ev,
       pd->endpoint_handler = ep->handler;
 #if MG_ENABLE_CALLBACK_USERDATA
       user_data = ep->user_data;
-      pd->user_data = ep->user_data;
 #endif
     }
   }
@@ -13015,11 +12998,8 @@ MG_INTERNAL int mg_sntp_parse_reply(const char *buf, int len,
 #endif
 
   mg_ntp_to_tv(trsm_ts_T3, &tv);
-  
-  msg->tv.tv_sec = tv.tv_sec + (delay / 1000000);
-  msg->tv.tv_usec = tv.tv_usec + (delay % 1000000);
 
-  msg->time = (double) msg->tv.tv_sec + (((double) msg->tv.tv_usec + delay) / 1000000.0);
+  msg->time = (double) tv.tv_sec + (((double) tv.tv_usec + delay) / 1000000.0);
 
   return 0;
 }
@@ -13099,9 +13079,6 @@ cleanup:
 
 struct sntp_data {
   mg_event_handler_t hander;
-#if MG_ENABLE_CALLBACK_USERDATA
-  void *user_data;
-#endif
   int count;
 };
 
@@ -13115,7 +13092,7 @@ static void mg_sntp_util_ev_handler(struct mg_connection *c, int ev,
   switch (ev) {
     case MG_EV_CONNECT:
       if (*(int *) ev_data != 0) {
-        mg_call(c, sd->hander, sd->user_data, MG_SNTP_FAILED, NULL);
+        mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);
         break;
       }
     /* fallthrough */
@@ -13125,20 +13102,19 @@ static void mg_sntp_util_ev_handler(struct mg_connection *c, int ev,
         mg_set_timer(c, mg_time() + 10);
         sd->count++;
       } else {
-        mg_call(c, sd->hander, sd->user_data, MG_SNTP_FAILED, NULL);
+        mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);
         c->flags |= MG_F_CLOSE_IMMEDIATELY;
       }
       break;
     case MG_SNTP_MALFORMED_REPLY:
-      mg_call(c, sd->hander, sd->user_data, MG_SNTP_FAILED, NULL);
+      mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);
       c->flags |= MG_F_CLOSE_IMMEDIATELY;
       break;
     case MG_SNTP_REPLY:
-      mg_call(c, sd->hander, sd->user_data, MG_SNTP_REPLY, ev_data);
+      mg_call(c, sd->hander, c->user_data, MG_SNTP_REPLY, ev_data);
       c->flags |= MG_F_CLOSE_IMMEDIATELY;
       break;
     case MG_EV_CLOSE:
-      mg_call(c, sd->hander, sd->user_data, MG_EV_CLOSE, NULL);
       MG_FREE(user_data);
       c->user_data = NULL;
       break;
@@ -13147,7 +13123,7 @@ static void mg_sntp_util_ev_handler(struct mg_connection *c, int ev,
 
 struct mg_connection *mg_sntp_get_time(struct mg_mgr *mgr,
                                        mg_event_handler_t event_handler,
-                                       const char *sntp_server_name MG_UD_ARG(void *user_data)) {
+                                       const char *sntp_server_name) {
   struct mg_connection *c;
   struct sntp_data *sd = (struct sntp_data *) MG_CALLOC(1, sizeof(*sd));
   if (sd == NULL) {
@@ -13162,10 +13138,6 @@ struct mg_connection *mg_sntp_get_time(struct mg_mgr *mgr,
   }
 
   sd->hander = event_handler;
-#if MG_ENABLE_CALLBACK_USERDATA
-  sd->user_data = user_data;  
-#endif
-
 #if !MG_ENABLE_CALLBACK_USERDATA
   c->user_data = sd;
 #endif